.\" $Revision: 1.1 $
.TH SHLOCK 1
.SH NAME
shlock \- create lock files for use in shell scripts
.SH SYNOPSIS
.B shlock
.BI \-p " pid"
.BI \-f " name"
[
.B \-b
]
[
.B \-u
]
[
.B \-c
]
.SH DESCRIPTION
.I Shlock
tries to create a lock file named
.I name
and write the process ID
.I pid
into it.
If the file already exists,
.I shlock
will read the process ID from the file and test to see if the process
is currently running.
If the process exists, then the file will not be created.
.PP
.I Shlock
exits with a zero status if it was able to create the lock file, or
non-zero if the file refers to currently-active process.
.SH OPTIONS
.TP
.B \-b
Process IDs are normally read and written in ASCII.
If the ``\-b'' flag is used, then they will be written as a binary
.IR int .
For compatibility with other systems, the ``\-u'' flag is accepted as
a synonym for ``\-b'' since binary locks are used by many UUCP packages.
.TP
.B \-c
If the ``\-c'' flag is used, then
.I shlock
will not create a lock file, but will instead use the file to see if
the lock is held by another program.
If the lock is valid, the program will exit with a non-zero status; if
the lock is not valid (i.e., invoking
.I shlock
without the flag would have succeeded), then the program will exit
with a zero status.
.SH EXAMPLES
The following example shows how
.I shlock
would be used within a shell script:
.sp 1
.nf
# setup
#
SHLOCK=/usr/local/bin/shlock

# obtain the lock
#
LOCK=/tmp/lock.progname	# XXX - change progname to basename of program
if [ ! -x "$SHLOCK" ]; then
    echo "$0: cannot find executable: $SHLOCK" 1>&2
    exit 1
fi
if ! "$SHLOCK" -p $$ -f "$LOCK"; then
    echo "$0: locked by process" `cat "$LOCK"` 1>&2
    exit 2
fi
# must trap after locking to avoid removal of another process lock
trap "rm -f $LOCK; exit" 0 1 2 3 15

# do something ...
.fi
.sp 1
If the script uses \-f to override locking, then one would use:
.sp 1
.nf
# setup
#
SHLOCK=/usr/local/bin/shlock

USAGE="usage: $0 [-f] arg ..."
F_FLAG=
set -- `/usr/bin/getopt f $*`
if [ $? != 0 ]; then
    echo "$0: unknown or invalid -flag" 1>&2
    echo $USAGE 1>&2
    exit 1
fi
for i in $*; do
    case "$i" in
    -f) F_FLAG="true" ;;
    esac
    shift
done
if [ $# -lt 1 ]; then
    echo "$0: must have at least one arg" 1>&2
    echo $USAGE 1>&2
    exit 2
fi

# ...

# obtain the lock
#
LOCK=/tmp/lock.progname	# XXX - change progname to basename of program
if [ ! -x "$SHLOCK" ]; then
    echo "$0: cannot find executable: $SHLOCK" 1>&2
    exit 3
fi
if ! "$SHLOCK" -p $$ -f "$LOCK"; then
    if [ -z "$FORCE" ]; then
	echo "$0: locked by process" `cat "$LOCK"` 1>&2
	exit 2
    else
    	# the -f forced a lock override, so we must not remove the lock
	LOCK=
    fi
fi
# must trap after locking to avoid removal of another process lock
trap "rm -f $LOCK; exit" 0 1 2 3 15

# do something ...
.fi
.SH HISTORY
Written by Rich $alz <rsalz@uunet.uu.net> after a description of HDB UUCP
locking given by Peter Honeyman.
.de R$
This is revision \\$3, dated \\$4.
..
.R$ $Id: shlock.1,v 1.1 2004/02/27 23:32:43 chongo Exp chongo $
